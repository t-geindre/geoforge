//kage:unit pixels
package renderer

const SeaLevel = 0.5

var Apron float
var ChunkSize float
var Zoom float
var Origin vec2
var LightPos vec2
var Ambient float

func Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {
    // --- local coords in chunk texture space ---
    local := (dstPos.xy - Origin) / Zoom

    a := Apron
    n := ChunkSize

    // Skip apron
    if local.x < a || local.y < a || local.x >= a+n || local.y >= a+n {
        return vec4(0.0)
    }

//return imageSrc0UnsafeAt(srcPos)



    // --- height sampling ---
    p := srcPos
    h := imageSrc0UnsafeAt(p).r

    // --- normal from heightmap ---
    eps := 1.0
    hx1 := imageSrc0UnsafeAt(p + vec2(eps, 0.0)).r
    hx0 := imageSrc0UnsafeAt(p - vec2(eps, 0.0)).r
    hy1 := imageSrc0UnsafeAt(p + vec2(0.0, eps)).r
    hy0 := imageSrc0UnsafeAt(p - vec2(0.0, eps)).r

    dx := (hx1 - hx0) * 0.5
    dy := (hy1 - hy0) * 0.5

    normalStrength := 70.0
    N := normalize(vec3(-dx*normalStrength, -dy*normalStrength, 1.0))

    // --- lighting vectors ---
    // Fragment position in screen space
    fragPos := dstPos.xy

    // Light direction from fragment to light
    L := normalize(vec3(LightPos - fragPos, 200.0))
    V := vec3(0.0, 0.0, 1.0) // camera looks straight down

    ndotl := clamp(dot(N, L), 0.0, 1.0)

    ambient := Ambient
    diffuse := ambient + (1.0 - ambient) * ndotl

    // --- biome color ---
    var base vec3

    // ===== WATER =====
    if h < SeaLevel {
        t := h / SeaLevel
        deep := vec3(0.02, 0.08, 0.25)
        shallow := vec3(0.10, 0.35, 0.60)
        base = mix(deep, shallow, t)

        // Flatten normal for water
        Nw := vec3(0.0, 0.0, 1.0)

        // Specular reflection (Blinnâ€“Phong)
        H := normalize(L + V)
        spec := pow(clamp(dot(Nw, H), 0.0, 1.0), 80.0)

        // Stronger spec near coast
        coast := smoothstep(0.7, 1.0, t)

        // Water lighting is flatter
        waterDiffuse := 0.55 + 0.45 * clamp(dot(Nw, L), 0.0, 1.0)

        colorOut := base * waterDiffuse
        colorOut += vec3(1.0) * spec * coast * 0.35

        return vec4(clamp(colorOut, 0.0, 1.0), 1.0)
    }

    // ===== BEACH =====
    if h < SeaLevel + 0.03 {
        base = vec3(0.85, 0.80, 0.60)
        diffuse = 0.45 + 0.55 * ndotl
        return vec4(base * diffuse, 1.0)
    }

    // ===== LAND =====
    t := (h - SeaLevel) / (1.0 - SeaLevel)

    if t < 0.35 {
        base = vec3(0.15, 0.55, 0.20) // plains
    } else if t < 0.60 {
        base = vec3(0.35, 0.45, 0.25) // hills
    } else if t < 0.85 {
        base = vec3(0.55, 0.55, 0.55) // mountains
    } else {
        base = vec3(0.95, 0.95, 0.95) // snow
        diffuse = 0.45 + 0.65 * ndotl
    }

    // cheap AO from slope
    slope := clamp((abs(dx) + abs(dy)) * normalStrength * 0.35, 0.0, 1.0)
    ao := 1.0 - 0.25 * slope

    col := base * diffuse * ao
    return vec4(clamp(col, 0.0, 1.0), 1.0)
}
